# GRAVI_TUBE
Infinite runner/racer with force fields


## Overview
**Gravitube** is a minimalistic 3D Infinite Runner game, where players move along an infinite tube, which is procedurally generated and destroyed as the player moves forward. The tube
is filled with different entities which include:
##### 1. Gems that serve as a collectible
#####  2. Walls that impede the player
#####  3. Powerups
#####   4. Checkpoints the refill the fuel.
The player assumes control over a simple space ship which is capable of creating force fields , that pulls space ship towards itself. The ship can also move along its viewing plane
for finer control. There is also a braking mechanism to slow down the ship at high speeds. The game features a single player mode where players can keep moving through the tube as 
 long as his fuel is sustained. The gems can be used to upgrade the ship's perfomance. Players also have the provision to change the color scheme of the tubes. All the purchases,
 high score, and remaining gems is stored locally in the device.
 The special powerups that pop up once in a while in the track gives the player some advantage for a limited time. There are two powerups in the game. 


 ##### 1. Boost
 This powerup powers the ship with a constant driving force along its viewing axis. This grants the ship a significant advantage in moving through the tube. The powerup also 
 temporarily deactivates walls within the tube for minimal movement impedance.
 ##### 2. Magnet
 This powerup attracts all the gems within the vicinity of the player , for a limited time. This is highly effective for collecting gems to increase ship's perfomance.
 
 
 It also features a multiplayer mode which is explained in the later section.
 
 The game is powered by the **Unity Game Engine**.
![Unity](https://unity3d.com/files/images/ogimg.jpg)
 
 ## Track Generation
 
 The track is generated by programmatically defining the position of each vertex and triangles of the tube. The tube is defined by an array of axes vectors. Each axes vector is
 inclined slightly differently relative to it's previous axes vector, so that turns are interpolated smoothly. Such a smooth gradient random effect is achieved by **Perlin Function**.
 
 Perlin noise is a "Pseudo Random" 2D height map which returns predictable random numbers between 0 and 1 for different values of x and y. A simple noise function is discontinuos and returns
 numbers which are far less predictable and jittered all over the place. Perlin function is continuos everywhere and gives a smoother result. It has been employed in many other scenarios
 like generating Minecraft terrain. Take a look at the below images for
 reference.
 
 [Simple Noise](https://miro.medium.com/max/375/1*H6lwuHlprj1GYqRmav_Y2A.png)
 [Perlin Noise](https://miro.medium.com/max/625/1*vs239SecVBaB4HvLsZ8O5Q.png)
 
 With the centers, axes vector and radius data in place for each segment of the tube, the locus of the circular section for each segment is determined mathematically in parametric form and this
 is used to define the location of all the vertices per section. As Unity allows generation of Meshes with maximum of 64000 vertices, The tube is made up of smaller subtubes for multiplayer.
 
 Other elements such as walls and bonuses are spawned at random locations within the tube, with their axes aligned parallel to the nearest axis vector of tube. Their initial rotation
 are randomized and some are are rotating while others are static. 
 
 ## Player Movement
 
 The force fields pull the players similar to a grapple hook(like a Hooke's spring), with its force proportional to its displacement vector. The ship has a speed limit which doesn't allow it
 to speed up even in presence of a force field. The speed limit and force strength can be upgraded. The ship also suffers a small opposite drag force proportinal to its velocity. The ship
 can also move freely within its viewing plane using WASD controls. The forcefield are created on mouse press and destroyed on mouse release. The handbrake is facilitated by Space.
 
 ## Multiplayer
  The networking part of the game is powered by the Photon engine. It is highly reliable engine which offers API at three different layers(high, low and mid level). This game used
  the free Package which can only support 20 concurrent players. 
  
  ![Photon Engine](https://blog.photonengine.com/wp-content/uploads/2013/10/x_unitynetworking-520x360.jpg)
  
  Players can host P2P races which other players can join and take part. The host can set the parameters of the race map such as:
 ##### Track Length: The length of the track to race.
 ##### Walls: Whether the track should have walls or not.
 ##### Upgrades: Whether the players can use their upgrades done to their ships or not.
 
 However gems are not included in race maps. After setting the parameters, the Host system automatically generates a random track whose seed is synchronized across other clients,
 including the location of walls, powerups, etc:- Other communications between clients(like finish, client disconnect, etc) , including the master client are handled by RPCs(Remote Procedure Calls). 
 If the Master Client leaves the game in the middle, the authority is designed to automatically migrate to the immediate next client. Players can form different rooms with custom properties which is
 open to all other players.
 
  ## Saving
  
  The player progress(High Score, Gems, Upgrades, Tube Color) is auto saved upon update of every game data using Player Preferences.
 
  
 
 
 
  
 
